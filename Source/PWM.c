/* ZS_lab8.c: PWM controls for timer
 *	Programmed by: Shamseddin Elmasri & Ziyad Mekhemer
 *  Date: Mar 11, 2020
 */
#include <stdio.h>
#include <stdint.h>
#include <math.h>
#include "common.h"

#define PI 3.1415926535

TIM_HandleTypeDef tim1;

//global variables
static uint16_t BreathingCycle[3] = { 0,0,0 };	//used to store duty cycle for each channel
static uint16_t modeSelection[3];		//array used to store selected mode for each channel

// FUNCTION      : PWMInit()
// DESCRIPTION   : Intializes the GPIO pins and timer 1 to be configured for PWM output 
// PARAMETERS    : Nothing
// RETURNS       : Nothing
void PWMInit(void) {

	GPIO_InitTypeDef  GPIO_InitStruct = { 0 };
	// Enabling clock for GPIOs
	__HAL_RCC_GPIOA_CLK_ENABLE();
	//configure GPIO pins	
	GPIO_InitStruct.Pin = GPIO_PIN_8 | GPIO_PIN_9 | GPIO_PIN_10;
	GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
	GPIO_InitStruct.Alternate = 6;
	HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
	//Enabling clock for TIM1
	__HAL_RCC_TIM1_CLK_ENABLE();
	tim1.Instance = TIM1;
	tim1.Init.Prescaler = HAL_RCC_GetPCLK2Freq() / 1000000 - 1;
	tim1.Init.CounterMode = TIM_COUNTERMODE_UP;
	tim1.Init.Period = 1000;
	tim1.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
	tim1.Init.RepetitionCounter = 0;

	TIM1->CR1 &= ~(TIM_CR1_URS); //can generate software interrupt by toggling UG bit in EGR
	TIM1->DIER |= 0b1; //setting Update Interrupt Enable bit 
	TIM1->EGR |= 0b1; //setting Update Generation bit
	HAL_TIM_Base_Init(&tim1);

	TIM_OC_InitTypeDef  sConfig;

	sConfig.OCMode = TIM_OCMODE_PWM1;
	sConfig.Pulse = 0;
	sConfig.OCPolarity = TIM_OCPOLARITY_HIGH;
	sConfig.OCNPolarity = TIM_OCNPOLARITY_LOW;
	sConfig.OCFastMode = TIM_OCFAST_DISABLE;
	sConfig.OCIdleState = TIM_OCIDLESTATE_RESET;
	sConfig.OCNIdleState = TIM_OCNIDLESTATE_RESET;

	HAL_TIM_PWM_ConfigChannel(&tim1, &sConfig, TIM_CHANNEL_1);
	HAL_TIM_PWM_Start(&tim1, TIM_CHANNEL_1);
	HAL_TIM_PWM_ConfigChannel(&tim1, &sConfig, TIM_CHANNEL_2);
	HAL_TIM_PWM_Start(&tim1, TIM_CHANNEL_2);
	HAL_TIM_PWM_ConfigChannel(&tim1, &sConfig, TIM_CHANNEL_3);
	HAL_TIM_PWM_Start(&tim1, TIM_CHANNEL_3);

	//Enable Interrupts TIM1_UP OR TIM1_CC
	//for general case use TIM1_UP, this interrupt should be entered everytime an UEV occurs
	//To use TIM1_UP intialize TIM16 because they both share the same address, pg 286 ref manual
	//for interrupts generated by CCR register use TIM1_CC
	HAL_NVIC_SetPriority(TIM1_CC_IRQn, 0, 1);//set to position 0 and priority 1
	NVIC_EnableIRQ(TIM1_CC_IRQn);
}

// FUNCTION      : PWM()
// DESCRIPTION   : Sets the duty cycle for the PWM waveform for a specified channel 
// PARAMETERS    : channel - 3 channels that can generate PWM waveforms independently
//                 value - duty cycle for the PWM waveform
// RETURNS       : Nothing
void PWM(uint32_t channel, int32_t value) {

	if (channel < 1 || channel > 3) {
		printf("Invalid channel %lu specified in %s()\n", channel, __FUNCTION__);
	}
	else if (channel == 1) {
		TIM1->CR1 &= ~TIM_CR1_CEN;
		TIM1->CCR1 = value;
		TIM1->CR1 |= TIM_CR1_CEN;

	}
	else if (channel == 2) {
		TIM1->CR1 &= ~TIM_CR1_CEN;
		TIM1->CCR2 = value;
		TIM1->CR1 |= TIM_CR1_CEN;

	}
	else if (channel == 3) {
		TIM1->CR1 &= ~TIM_CR1_CEN;
		TIM1->CCR3 = value;
		TIM1->CR1 |= TIM_CR1_CEN;
	}
}

// FUNCTION      : PWMbreathing()
// DESCRIPTION   : PWM waveform that will generate a breathing profile for an LED. This is done by increasing the duty cycle by 0.1% linearly, when
//                 100% duty cycle is reached the duty cycle will decrement by 0.1% until 0% duty cycle is reached. The rate of change of the duty cycle
//                 is inversly proportional to the timer 1 period.
// PARAMETERS    : uint32_t channel: 3 channels that can generate PWM waveforms independently
// RETURNS       : Nothing
void PWMbreathing(uint32_t channel) {
	static uint16_t BreathingCycleFlag[3] = { 1,1,1 }; //used as a flag to control direction of linear function (rising/falling)
	volatile uint32_t* channelAddress = (volatile uint32_t*)(0x40012C00 + 0x34 + (0x04 * (channel - 1)));//pointer used to point to TIMx_CCRx
														   //base address for TIM1 + offset of CCRx + increment (depending on channel)
	if (BreathingCycleFlag[channel - 1] == 1) {
		BreathingCycle[channel - 1] = BreathingCycle[channel - 1] + (tim1.Init.Period / 1000);	//incrementing duty cycle by 0.1%
	}
	else {
		BreathingCycle[channel - 1] = BreathingCycle[channel - 1] - (tim1.Init.Period / 1000);	//decrementing duty cycle by 0.1%
	}
	*channelAddress = BreathingCycle[channel - 1];	//copying value of duty cycle to CCRx register
	if (BreathingCycle[channel - 1] == tim1.Init.Period || BreathingCycle[channel - 1] == 0) {	//checking if boundaries have been reached
		BreathingCycleFlag[channel - 1] = -BreathingCycleFlag[channel - 1];			//updating flag
	}
}

// FUNCTION      : pwmSine()
// DESCRIPTION   : Calculates the duty cycle for the selected channel. Duty cycle changes in a rectified sinusoidal form
// PARAMETERS    : uint32_t channel: 3 channels that can generate PWM waveforms independently
// RETURNS       : Nothing
void pwmSine(uint32_t channel) {
	static int delta = 1; //represents step-size
	static int i = 0;     // used to change angle of Sine function
	volatile uint32_t* channelAddress = (volatile uint32_t*)(0x40012C00 + 0x34 + (0x04 * (channel - 1)));//pointer used to point to TIMx_CCRx
														   //base address for TIM1 + offset of CCRx + increment (depending on channel)
	BreathingCycle[channel - 1] = tim1.Init.Period * sin(((float)i / 1000) * (PI / 2));// calculating duty cycle
	*channelAddress = BreathingCycle[channel - 1]; //copying value of duty cycle to CCRx register
	i = i + delta;			//jumping up/down based on sign of delta
	if (i == 0 || i > 1000) {	//setting boundaries of duty cycle
		delta = -delta;		// switching between rising and falling (rising before PI/2, and falling after PI/2)
	}
}
// FUNCTION      : pwmPar()
// DESCRIPTION   : Calculates the duty cycle for the selected channel. Duty cycle changes in a parabolic form
// PARAMETERS    : uint32_t channel: 3 channels that can generate PWM waveforms independently
// RETURNS       : Nothing
void pwmPar(uint32_t channel) {
	static int j = 1; //used as the independant variable (x-axis) in the parabolic function
	volatile uint32_t* channelAddress = (volatile uint32_t*)(0x40012C00 + 0x34 + (0x04 * (channel - 1)));//pointer used to point to TIMx_CCRx
														   //base address for TIM1 + offset of CCRx + increment (depending on channel)
	BreathingCycle[channel - 1] = tim1.Init.Period * (-4 * ((float)j / 1000) * ((float)j / 1000 - 1)); // equation used: y = -4x(x-1)
	*channelAddress = BreathingCycle[channel - 1];		//copying value of duty cycle to CCRx register
	if (j == 1000) {	//setting boundaries of the parabolic function
		j = 1;	//restarting breathing cycle
	}
	j++;
}
/*************Commands****************************/
ParserReturnVal_t CmdPWMInit(int mode) {

	if (mode != CMD_INTERACTIVE) return CmdReturnOk;

	PWMInit();	//initialized timer 1 with 3 channels as PWM

	return CmdReturnOk;
}
ADD_CMD("PWMInit", CmdPWMInit, "		intializes timer 1 and GPIO to be able to output PWM waveforms")

//This command generates a PWM waveform dependent on the user selection
//Modes: 0 = PWM waveform              1 = linear breathing PWM profile
//       2 = Sine PWM profile          3 = parabolic PWM profile
ParserReturnVal_t CmdPWM(int mode) {

	uint32_t channel, dutyCycle;
	uint16_t rc, modeType;

	if (mode != CMD_INTERACTIVE) return CmdReturnOk;

	rc = fetch_uint32_arg(&channel);	//inputting channel number from user
	if (rc) {
		printf("Please supply a channel number\n");
		return CmdReturnBadParameter1;
	}
	if (channel > 3 || channel < 1) {	//checking if channel number is valid 
		printf("channel must be 1, 2 or 3\n");
		return CmdReturnBadParameter1;
	}
	rc = fetch_uint16_arg(&modeType);	//inputting modeType from user
	if (rc) {
		printf("Please supply modeType\n");
		return CmdReturnBadParameter2;
	}
	if (modeType > 3 || modeType < 0) {	//checking if modeType selected is valid 
		printf("modeType must be 0, 1, 2 or 3\n");
		return CmdReturnBadParameter2;
	}
	if (modeType == 0) {
		rc = fetch_uint32_arg(&dutyCycle);//inputting dutyCycle only if modeType equals 0
		if (rc) {
			printf("Please supply dutyCycle\n");
			return CmdReturnBadParameter3;
		}
		if (dutyCycle < 1 || dutyCycle > 100) { //checking if dutyCyle selected is valid
			printf("dutyCycle must be between 0 and 100\n");
			return CmdReturnBadParameter3;
		}
		dutyCycle = dutyCycle * tim1.Init.Period / 100; //converting dutyCyle to microseconds
		TIM1->DIER &= ~(1 << channel);  //disabling interrupt for counter compare match by setting CCxIE bit low
		PWM(channel, dutyCycle);	//setting the duty cycle for the selected channel
	}
	else {	/***PWMbreathing initilazation block***/
		volatile uint32_t* channelAddress = (volatile uint32_t*)(0x40012C00 + 0x34 + (0x04 * (channel - 1))); //pointer used to point to TIMx_CCRx
														   //base address for TIM1 + offset of CCRx + increment (depending on channel)
		TIM1->DIER |= (1 << channel);//enabling interrupt for counter compare match by setting CCxIE bit high
		BreathingCycle[channel - 1] = (tim1.Init.Period / 1000); //starting duty cycle at 0.1%
		TIM1->CR1 &= ~TIM_CR1_CEN;	//stopping timer
		*channelAddress = BreathingCycle[channel - 1];// copying value of duty cycle to TIMx_CCRx register
		TIM1->CR1 |= TIM_CR1_CEN;	//starting timer
	}
	modeSelection[channel - 1] = modeType;	//storing modeType in array to keep track of channels
	return CmdReturnOk;
}
ADD_CMD("PWM", CmdPWM, "<channel> <mode> <dutycycle>      Sets PWM channel, mode, and dutycyle if mode equals 0")

/***************ISR***************/
// FUNCTION      : TIM1_CC_IRQHandler
// DESCRIPTION   : Interrupt for controlling the PWM duty cycle for BreathingPWM for the TIM1 CC register.
// PARAMETERS    : Nothing
// RETURNS       : Nothing
void TIM1_CC_IRQHandler(void) {

	int channel;
	//checking interrupt flags
	if (TIM1->SR & TIM_SR_CC1IF) {	//Capture Compare register 1
		channel = 1;
		TIM1->SR &= ~TIM_SR_CC1IF;// Resetting the CC1 Interrupt Flag to 0
	}
	if (TIM1->SR & TIM_SR_CC2IF) {	//Capture Compare register 2
		channel = 2;
		TIM1->SR &= ~TIM_SR_CC2IF;// Resetting the CC2 Interrupt Flag to 0
	}
	if (TIM1->SR & TIM_SR_CC3IF) {	//Capture Compare register 3
		channel = 3;
		TIM1->SR &= ~TIM_SR_CC3IF;// Resetting the CC3 Interrupt Flag to 0
	}
	TIM1->CR1 &= ~TIM_CR1_CEN; 	//stopping timer
	//updating duty cycle on breathing profile function based on mode selected 
	if (modeSelection[channel - 1] == 1) {
		PWMbreathing(channel);
	}
	else if (modeSelection[channel - 1] == 2) {
		pwmSine(channel);
	}
	else if (modeSelection[channel - 1] == 3) {
		pwmPar(channel);
	}
	TIM1->CR1 |= TIM_CR1_CEN;	//starting timer
}
